<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大先生討伐戦 - Operation: Fact Check</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; user-select: none; }
        
        /* Start Screen */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; z-index: 10;
        }
        .btn {
            background: #ff4757; color: white; padding: 15px 30px; 
            font-size: 24px; border: none; border-radius: 5px; cursor: pointer;
            margin-top: 20px; transition: transform 0.1s;
            font-weight: bold; text-transform: uppercase;
        }
        .btn:hover { transform: scale(1.05); background: #ff6b81; }
        
        /* HUD */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' fill='none' stroke='cyan' stroke-width='5'%3E%3Ccircle cx='50' cy='50' r='40' /%3E%3Cline x1='50' y1='20' x2='50' y2='40' /%3E%3Cline x1='50' y1='60' x2='50' y2='80' /%3E%3Cline x1='20' y1='50' x2='40' y2='50' /%3E%3Cline x1='60' y1='50' x2='80' y2='50' /%3E%3C/svg%3E");
            transform: translate(-50%, -50%); opacity: 0.8;
        }
        
        /* Bars */
        .bar-container { position: absolute; height: 20px; background: #333; border: 2px solid white; border-radius: 10px; overflow: hidden; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.2s; }
        
        #player-hp-bar { bottom: 20px; left: 20px; width: 300px; }
        #player-hp-fill { background: #2ed573; }
        
        #boss-hp-bar { top: 20px; left: 50%; transform: translateX(-50%); width: 60%; height: 30px; display: none; }
        #boss-hp-fill { background: #ff4757; }
        #boss-name { 
            position: absolute; top: 25px; left: 50%; transform: translate(-50%, -50%); 
            color: white; font-weight: bold; text-shadow: 1px 1px 2px black; font-size: 14px;
            pointer-events: none; display: none;
        }

        /* Messages */
        #message-area {
            position: absolute; top: 15%; width: 100%; text-align: center;
            font-size: 32px; font-weight: bold; color: yellow;
            text-shadow: 2px 2px 0 #000; opacity: 0; transition: opacity 0.5s;
        }
        
        /* Upload Area */
        #upload-area {
            border: 2px dashed #aaa; padding: 20px; margin-bottom: 20px; text-align: center; background: rgba(255,255,255,0.1); border-radius: 10px;
        }
        input[type="file"] { display: none; }
        .upload-label { cursor: pointer; color: cyan; text-decoration: underline; }
        #preview-img { max-width: 100px; max-height: 100px; border-radius: 50%; margin-top: 10px; border: 2px solid white; display: none; }

        /* Game Over / Win */
        #result-screen { 
            display: none; 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); 
            z-index: 20; 
            flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        #result-title { font-size: 60px; margin-bottom: 20px; }
        #result-desc { font-size: 24px; margin-bottom: 30px; max-width: 600px; text-align: center; line-height: 1.5; }

        .key-guide { margin-top: 20px; font-size: 14px; color: #aaa; text-align: center; }
        kbd { background: #333; padding: 2px 6px; border-radius: 4px; border: 1px solid #555; font-family: monospace; }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="player-hp-bar"><div id="player-hp-fill" class="bar-fill"></div></div>
        <div id="boss-hp-bar">
            <div id="boss-name">大先生 (DAI-SENSEI) - 進捗率 100% (未着手)</div>
            <div id="boss-hp-fill" class="bar-fill"></div>
        </div>
        <div id="message-area"></div>
    </div>

    <div id="start-screen">
        <h1>大先生討伐戦</h1>
        <p>オフィスに蔓延る曖昧さを、事実の弾丸で撃ち抜こう。</p>
        
        <div id="upload-area">
            <p>※オリジナル画像を使いたい場合は選択してください</p>
            <label for="file-input" class="upload-label">画像ファイルを選択</label>
            <input type="file" id="file-input" accept="image/*">
            <br>
            <img id="preview-img" alt="Boss Preview">
        </div>

        <button class="btn" id="start-btn">ミーティング開始 (START)</button>
        
        <div class="key-guide">
            <p>移動: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> | 視点: <kbd>マウス</kbd></p>
            <p>攻撃(指摘): <kbd>左クリック</kbd> | ダッシュ: <kbd>Shift</kbd></p>
        </div>
    </div>

    <!-- Corrected Result Screen ID structure -->
    <div id="result-screen">
        <h1 id="result-title"></h1>
        <p id="result-desc"></p>
        <button class="btn" onclick="location.reload()">再調整 (RELOAD)</button>
    </div>

    <script>
        // --- Game Constants & State ---
        let scene, camera, renderer;
        let player = { hp: 100, maxHp: 100, speed: 15, velocity: new THREE.Vector3(), direction: new THREE.Vector3() };
        let boss = { 
            obj: null, hp: 1000, maxHp: 1000, 
            state: 'IDLE', // IDLE, ATTACK, FLEE
            nextAttackTime: 0,
            moveSpeed: 8
        };
        let projectiles = [];
        let particles = [];
        let clock = new THREE.Clock();
        let isGameRunning = false;
        let controls;
        let bossTexture = null; // To store the uploaded texture

        // --- Quotes ---
        const bossQuotes = [
            "ちょうどやろうと思ってました",
            "ボールは向こうにあります",
            "認識のズレですね",
            "アグリーです",
            "一旦持ち帰ります",
            "ほぼ出来てます",
            "共有事項として...",
            "ドラスティックな変更が...",
            "承知です",
            "娘の送迎がありますのでこの辺で業務終了します",
            "今日は分断で業務させていただきます"
        ];

        const playerBullets = [
            "事実確認", "議事録", "納期", "責任", "Why?", "誰がやるの？"
        ];

        // --- Init Function ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x111111, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // Floor (Abstract Office Grid)
            const gridHelper = new THREE.GridHelper(200, 50, 0x00ffff, 0x333333);
            scene.add(gridHelper);

            // Floating Documents (Environment Decor)
            createEnvironmentDecor();

            // Controls (PointerLock)
            setupControls();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousedown', onMouseDown);
            
            // Start Loop
            animate();
        }

        // --- File Upload Logic ---
        const fileInput = document.getElementById('file-input');
        const previewImg = document.getElementById('preview-img');
        
        fileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(evt) {
                    previewImg.src = evt.target.result;
                    previewImg.style.display = 'block';
                    
                    // Create Texture
                    const img = new Image();
                    img.src = evt.target.result;
                    img.onload = () => {
                        // Create a circular cropped canvas texture
                        const canvas = document.createElement('canvas');
                        canvas.width = 512;
                        canvas.height = 512;
                        const ctx = canvas.getContext('2d');
                        
                        // Background glow
                        const grad = ctx.createRadialGradient(256,256,100, 256,256,250);
                        grad.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                        grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        ctx.fillStyle = grad;
                        ctx.fillRect(0,0,512,512);

                        // Clip circle
                        ctx.beginPath();
                        ctx.arc(256, 256, 200, 0, Math.PI * 2);
                        ctx.closePath();
                        ctx.clip();
                        
                        // Draw Image
                        ctx.drawImage(img, 0, 0, 512, 512);
                        
                        // Border
                        ctx.strokeStyle = '#ffcc00';
                        ctx.lineWidth = 15;
                        ctx.stroke();

                        bossTexture = new THREE.CanvasTexture(canvas);
                    };
                }
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            if (!bossTexture) {
                // Fallback texture if none uploaded
                createDefaultBossTexture();
            }
            spawnBoss();
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('boss-hp-bar').style.display = 'block';
            document.getElementById('boss-name').style.display = 'block';
            controls.lock();
            isGameRunning = true;
        });

        function createDefaultBossTexture() {
            // "大先生"のイラストの特徴をCanvasで再現
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // --- 背景 (オーラ) ---
            const grad = ctx.createRadialGradient(256, 256, 100, 256, 256, 250);
            grad.addColorStop(0, '#fdfd96'); // 薄黄色
            grad.addColorStop(1, '#ff6b6b'); // 赤み
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(256, 256, 250, 0, Math.PI * 2); ctx.fill();

            // --- 輪郭 (丸顔) ---
            ctx.fillStyle = '#ffdbac'; // 肌色
            ctx.beginPath(); 
            ctx.ellipse(256, 256, 140, 160, 0, 0, Math.PI * 2); 
            ctx.fill();
            ctx.lineWidth = 6; ctx.strokeStyle = '#4a3b2a'; ctx.stroke();

            // --- 耳 ---
            ctx.beginPath(); ctx.arc(110, 250, 30, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); // 左耳
            ctx.beginPath(); ctx.arc(402, 250, 30, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); // 右耳

            // --- 頭のシワ/髪の毛 (薄い) ---
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(256, 256, 140, Math.PI*1.2, Math.PI*1.8); ctx.stroke(); // 頭頂部
            ctx.beginPath(); ctx.moveTo(220, 150); ctx.lineTo(290, 150); ctx.stroke(); // おでこのシワ

            // --- 眼鏡 (太いフレーム) ---
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.strokeStyle = '#2d3436';
            ctx.lineWidth = 10;

            // 左レンズ
            ctx.fillRect(160, 210, 80, 60);
            ctx.strokeRect(160, 210, 80, 60);
            
            // 右レンズ
            ctx.fillRect(272, 210, 80, 60);
            ctx.strokeRect(272, 210, 80, 60);

            // ブリッジ
            ctx.beginPath(); ctx.moveTo(240, 230); ctx.lineTo(272, 230); ctx.stroke();

            // --- 目 (ジト目・半目) ---
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(200, 240, 8, 0, Math.PI * 2); ctx.fill(); // 左目
            ctx.beginPath(); ctx.arc(312, 240, 8, 0, Math.PI * 2); ctx.fill(); // 右目

            // 瞼 (やる気のなさ)
            ctx.fillStyle = '#ffdbac';
            ctx.fillRect(155, 205, 90, 30);
            ctx.fillRect(267, 205, 90, 30);

            // --- 眉毛 (自信ありげに上がっている) ---
            ctx.strokeStyle = '#000'; ctx.lineWidth = 6;
            ctx.beginPath(); ctx.moveTo(160, 180); ctx.quadraticCurveTo(200, 160, 240, 180); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(272, 180); ctx.quadraticCurveTo(312, 160, 352, 180); ctx.stroke();

            // --- 口 (ニヤけ / への字の逆) ---
            ctx.beginPath();
            ctx.moveTo(200, 340);
            ctx.quadraticCurveTo(256, 380, 312, 330); // ニヤリ
            ctx.stroke();
            // 口角のシワ
            ctx.beginPath(); ctx.moveTo(312, 330); ctx.lineTo(320, 325); ctx.stroke();

            // --- 汗 (焦り) ---
            ctx.fillStyle = '#74b9ff';
            ctx.beginPath(); ctx.arc(360, 200, 10, 0, Math.PI*2); ctx.fill();
            
            // --- テクスチャ化 ---
            bossTexture = new THREE.CanvasTexture(canvas);
        }

        // --- Game Logic functions ---

        function setupControls() {
            // Simplified PointerLock logic
            const Controls = function ( camera, domElement ) {
                this.camera = camera;
                this.domElement = domElement;
                this.isLocked = false;
                
                // Euler angles
                const euler = new THREE.Euler( 0, 0, 0, 'YXZ' );
                const PI_2 = Math.PI / 2;
                const vec = new THREE.Vector3();

                this.lock = function() { this.domElement.requestPointerLock(); };
                this.unlock = function() { document.exitPointerLock(); };

                const onMouseMove = ( event ) => {
                    if ( !this.isLocked ) return;
                    const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                    euler.setFromQuaternion( camera.quaternion );
                    euler.y -= movementX * 0.002;
                    euler.x -= movementY * 0.002;
                    euler.x = Math.max( - PI_2, Math.min( PI_2, euler.x ) );
                    camera.quaternion.setFromEuler( euler );
                };

                const onPointerlockChange = () => {
                    this.isLocked = ( document.pointerLockElement === this.domElement );
                };

                document.addEventListener( 'mousemove', onMouseMove, false );
                document.addEventListener( 'pointerlockchange', onPointerlockChange, false );

                this.moveForward = false;
                this.moveBackward = false;
                this.moveLeft = false;
                this.moveRight = false;
                this.sprint = false;

                const onKeyDown = ( event ) => {
                    switch ( event.code ) {
                        case 'ArrowUp': case 'KeyW': this.moveForward = true; break;
                        case 'ArrowLeft': case 'KeyA': this.moveLeft = true; break;
                        case 'ArrowDown': case 'KeyS': this.moveBackward = true; break;
                        case 'ArrowRight': case 'KeyD': this.moveRight = true; break;
                        case 'ShiftLeft': this.sprint = true; break;
                    }
                };
                const onKeyUp = ( event ) => {
                    switch ( event.code ) {
                        case 'ArrowUp': case 'KeyW': this.moveForward = false; break;
                        case 'ArrowLeft': case 'KeyA': this.moveLeft = false; break;
                        case 'ArrowDown': case 'KeyS': this.moveBackward = false; break;
                        case 'ArrowRight': case 'KeyD': this.moveRight = false; break;
                        case 'ShiftLeft': this.sprint = false; break;
                    }
                };
                document.addEventListener( 'keydown', onKeyDown, false );
                document.addEventListener( 'keyup', onKeyUp, false );
            };
            controls = new Controls(camera, document.body);
        }

        function spawnBoss() {
            const material = new THREE.SpriteMaterial({ map: bossTexture });
            boss.obj = new THREE.Sprite(material);
            boss.obj.scale.set(6, 6, 1);
            boss.obj.position.set(0, 3, -15);
            scene.add(boss.obj);
        }

        function createEnvironmentDecor() {
            const geom = new THREE.BoxGeometry(0.5, 0.8, 0.05);
            const mat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
            for(let i=0; i<50; i++) {
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 80,
                    Math.random() * 20,
                    (Math.random() - 0.5) * 80
                );
                mesh.rotation.x = Math.random() * Math.PI;
                mesh.rotation.y = Math.random() * Math.PI;
                scene.add(mesh);
            }
        }

        function createTextTexture(text, color, bgColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // Bubble background
            ctx.fillStyle = bgColor || 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = color || '#000';
            ctx.lineWidth = 5;
            
            // Rounded rect
            const x=10, y=10, w=492, h=108, r=20;
            ctx.beginPath();
            ctx.moveTo(x+r, y);
            ctx.lineTo(x+w-r, y);
            ctx.quadraticCurveTo(x+w, y, x+w, y+r);
            ctx.lineTo(x+w, y+h-r);
            ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
            ctx.lineTo(x+r, y+h);
            ctx.quadraticCurveTo(x, y+h, x, y+h-r);
            ctx.lineTo(x, y+r);
            ctx.quadraticCurveTo(x, y, x+r, y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Text
            ctx.font = 'bold 40px Arial';
            ctx.fillStyle = color || 'black';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            
            return new THREE.CanvasTexture(canvas);
        }

        function onMouseDown() {
            if(!isGameRunning) return;
            shootPlayerProjectile();
        }

        function shootPlayerProjectile() {
            // Pick a random "weapon" text
            const text = playerBullets[Math.floor(Math.random() * playerBullets.length)];
            const texture = createTextTexture(text, '#fff', '#007aff');
            
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(3, 0.75, 1);
            
            // Start at camera position, slightly offset
            const vector = new THREE.Vector3(0, 0, -1);
            vector.applyQuaternion(camera.quaternion);
            
            sprite.position.copy(camera.position).add(vector.clone().multiplyScalar(1));
            
            scene.add(sprite);
            
            projectiles.push({
                obj: sprite,
                velocity: vector.multiplyScalar(40), // Fast speed
                isPlayer: true,
                damage: 25,
                life: 3
            });
            
            // Recoil
            camera.position.y += 0.05;
        }

        function bossAttack() {
            if(!boss.obj) return;
            
            const text = bossQuotes[Math.floor(Math.random() * bossQuotes.length)];
            const texture = createTextTexture(text, '#000', '#ffcc00');
            
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture }));
            sprite.scale.set(5, 1.25, 1);
            sprite.position.copy(boss.obj.position);
            
            // Aim at player
            const direction = new THREE.Vector3().subVectors(camera.position, boss.obj.position).normalize();
            
            scene.add(sprite);
            
            projectiles.push({
                obj: sprite,
                velocity: direction.multiplyScalar(15),
                isPlayer: false,
                damage: 15,
                life: 5
            });

            showMessage(`大先生: 「${text}」`);
        }

        function showMessage(msg) {
            const el = document.getElementById('message-area');
            el.innerText = msg;
            el.style.opacity = 1;
            setTimeout(() => { el.style.opacity = 0; }, 2000);
        }

        function updateParticles(dt) {
            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.life -= dt;
                p.obj.position.add(p.velocity.clone().multiplyScalar(dt));
                p.obj.material.opacity = p.life;
                if(p.life <= 0) {
                    scene.remove(p.obj);
                    particles.splice(i, 1);
                }
            }
        }

        function createExplosion(pos, color) {
            for(let i=0; i<10; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                scene.add(mesh);
                
                particles.push({
                    obj: mesh,
                    velocity: new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10),
                    life: 1.0
                });
            }
        }

        function gameOver(win) {
            isGameRunning = false;
            controls.unlock();
            const screen = document.getElementById('result-screen');
            const title = document.getElementById('result-title');
            const desc = document.getElementById('result-desc');
            
            // Error fix: Ensure element exists before accessing properties
            if (screen) {
                screen.style.display = 'flex';
                if(win) {
                    title.innerText = "MISSION COMPLETE";
                    title.style.color = "#2ed573";
                    desc.innerText = "大先生は「あとは若手でよろしく」と言い残し、会議室から退出しました。\nプロジェクトの平和は守られました。";
                } else {
                    title.innerText = "MISSION FAILED";
                    title.style.color = "#ff4757";
                    desc.innerText = "あなたは言いくるめられ、炎上案件の責任者に任命されました。\n大先生は定時で帰宅しました。";
                }
            } else {
                console.error("Result screen element not found!");
            }
        }

        // --- Main Update Loop ---

        function animate() {
            requestAnimationFrame(animate);

            if (!isGameRunning) {
                renderer.render(scene, camera);
                return;
            }

            const dt = clock.getDelta();

            // --- Player Movement ---
            player.velocity.x -= player.velocity.x * 10.0 * dt;
            player.velocity.z -= player.velocity.z * 10.0 * dt;
            player.velocity.y -= player.velocity.y * 10.0 * dt;

            player.direction.z = Number(controls.moveForward) - Number(controls.moveBackward);
            player.direction.x = Number(controls.moveRight) - Number(controls.moveLeft);
            player.direction.normalize();

            const speed = controls.sprint ? player.speed * 1.8 : player.speed;

            if (controls.moveForward || controls.moveBackward) player.velocity.z -= player.direction.z * speed * dt;
            if (controls.moveLeft || controls.moveRight) player.velocity.x -= player.direction.x * speed * dt;

            controls.camera.translateX(-player.velocity.x * dt);
            controls.camera.translateZ(-player.velocity.z * dt);
            
            // Keep player inside reasonable bounds
            camera.position.y = 1.6; // Walking height
            if(camera.position.length() > 90) camera.position.setLength(90);

            // --- Boss AI ---
            if (boss.obj) {
                const distToPlayer = boss.obj.position.distanceTo(camera.position);
                
                // Behavior Logic
                // If HP < 300, Panic Mode (Runs away)
                const isPanic = boss.hp < 300;
                
                if (isPanic) {
                    boss.obj.material.color.setHex(0xffaaaa); // Red tint
                    // Move away from player
                    const runDir = new THREE.Vector3().subVectors(boss.obj.position, camera.position).normalize();
                    // Stay within arena
                    if (boss.obj.position.length() > 80) {
                        // Move sideways if hitting wall
                        runDir.cross(new THREE.Vector3(0,1,0));
                    }
                    boss.obj.position.add(runDir.multiplyScalar(boss.moveSpeed * 2 * dt));
                } else {
                    // Move randomly or towards player slowly
                    boss.obj.position.x += Math.sin(clock.elapsedTime) * 5 * dt;
                    boss.obj.position.y = 3 + Math.sin(clock.elapsedTime * 2) * 2;
                }

                // Attack logic
                if (clock.elapsedTime > boss.nextAttackTime) {
                    bossAttack();
                    // Attack faster as HP drops
                    const attackInterval = isPanic ? 0.5 : (1.0 + (boss.hp / boss.maxHp) * 2.0); 
                    boss.nextAttackTime = clock.elapsedTime + attackInterval;
                }
            }

            // --- Projectiles ---
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                p.life -= dt;
                
                // Move
                p.obj.position.add(p.velocity.clone().multiplyScalar(dt));
                
                let hit = false;
                
                // Collision: Player Bullet vs Boss
                if (p.isPlayer && boss.obj) {
                    if (p.obj.position.distanceTo(boss.obj.position) < 3.0) {
                        boss.hp -= p.damage;
                        createExplosion(p.obj.position, 0x00ffff);
                        hit = true;
                        
                        // Update Boss UI
                        const pct = Math.max(0, (boss.hp / boss.maxHp) * 100);
                        document.getElementById('boss-hp-fill').style.width = pct + '%';
                        
                        // Flash Boss
                        boss.obj.material.opacity = 0.5;
                        setTimeout(() => { if(boss.obj) boss.obj.material.opacity = 1; }, 100);

                        if(boss.hp <= 0) {
                            createExplosion(boss.obj.position, 0xffaa00);
                            scene.remove(boss.obj);
                            boss.obj = null;
                            gameOver(true);
                        }
                    }
                }
                
                // Collision: Boss Bullet vs Player
                if (!p.isPlayer) {
                    if (p.obj.position.distanceTo(camera.position) < 2.0) {
                        player.hp -= p.damage;
                        createExplosion(camera.position.clone().add(new THREE.Vector3(0,0,-1)), 0xff0000);
                        hit = true;
                        
                        // Shake camera
                        camera.position.x += (Math.random()-0.5);
                        camera.position.y += (Math.random()-0.5);

                        // Update UI
                        const pct = Math.max(0, (player.hp / player.maxHp) * 100);
                        document.getElementById('player-hp-fill').style.width = pct + '%';

                        if(player.hp <= 0) {
                            gameOver(false);
                        }
                    }
                }

                if (hit || p.life <= 0) {
                    scene.remove(p.obj);
                    projectiles.splice(i, 1);
                }
            }

            updateParticles(dt);
            renderer.render(scene, camera);
        }

        // Setup
        init();

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>